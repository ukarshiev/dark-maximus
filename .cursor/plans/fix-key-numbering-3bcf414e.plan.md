<!-- 3bcf414e-b1b5-4413-ba09-69b29d13b304 d812fa6c-eb56-4d03-b31a-bcdded2a4672 -->
# Критическая проблема: ключи не сохраняются в БД

Дата: 14.11.2025 14:10
Версия: 1.1

## Проблема (на основе фактических данных)

**Факты из логов и БД:**

1. Все покупки сегодня (14.11) используют **один и тот же ключ ID 131**, созданный **12.11**
2. Последний новый ключ в БД - **ID 134 от 13.11** (триал)
3. В логах все покупки генерируют токен для `key 131`, но не видно логов `"Created permanent token for new key_id=..."` для новых ключей
4. `get_next_key_number` возвращает `len(keys) + 1`, где keys - все ключи пользователя (включая удаленные/истекшие)

**Вероятная причина:**

- При создании нового ключа формируется email: `user{user_id}-key{key_number}@{host_code}.bot`
- `key_number` вычисляется через `get_next_key_number(user_id)` = `len(keys) + 1`
- Если ключи удаляются (scheduler удаляет истекшие более 5 дней), `get_next_key_number` возвращает неправильный номер
- В результате формируется email, который **уже существует в БД**
- `add_new_key` ловит `IntegrityError` и **обновляет существующий ключ** вместо создания нового (строки 6186-6247 в database.py)
- Поэтому все новые покупки обновляют старый ключ 131 вместо создания новых

**Дополнительная проблема:** Scheduler может удалять ключи, если не находит их на сервере (строки 1079-1082 в scheduler.py), но это не основная причина

## Решение

### 1. Добавить счетчик ключей в таблицу users

- Добавить поле `keys_count INTEGER DEFAULT 0` в таблицу `users`
- Создать миграцию для добавления поля в существующую БД
- Инициализировать счетчик для существующих пользователей (максимальный номер ключа)

### 2. Изменить функцию `get_next_key_number`

- Использовать счетчик `keys_count` из таблицы `users` вместо подсчета ключей
- Инкрементировать счетчик атомарно при получении следующего номера
- Возвращать `keys_count + 1` как следующий номер
- Логировать вызов функции для диагностики

### 3. Обновить логику создания ключа

- Использовать номер ключа из `get_next_key_number` для формирования email
- После создания ключа использовать тот же номер (не пересчитывать)
- Добавить логирование номера ключа и email перед вызовом `add_new_key`
- При IntegrityError логировать детали (email, существующий key_id) для диагностики

### 4. Обновить логику отображения ключа

- При отображении ключа использовать номер из БД, если он есть
- Если номера нет (старые ключи), вычислять на основе `created_date` или использовать `key_id`

### 5. Обновить функции в scheduler.py

- При отображении номера ключа в уведомлениях использовать номер из БД
- Если номера нет, вычислять на основе существующих ключей

### 6. Тестирование

- Проверить создание нового ключа для пользователя с существующими ключами
- Проверить создание ключа после удаления старых ключей
- Проверить отображение номера ключа в сообщениях
- Проверить отображение номера ключа в уведомлениях

## Файлы для изменения

1. `src/shop_bot/data_manager/database.py`

- Добавить миграцию для поля `keys_count` в таблицу `users`
- Изменить функцию `get_next_key_number` для использования счетчика и атомарного инкремента
- Добавить функцию `increment_user_keys_count` для атомарного инкремента счетчика
- Обновить функцию `add_new_key` для логирования при IntegrityError
- Добавить функцию инициализации счетчика для существующих пользователей

2. `src/shop_bot/bot/handlers.py`

- Добавить логирование номера ключа и email перед вызовом `add_new_key`
- Использовать номер ключа из БД при отображении (не пересчитывать)

3. `src/shop_bot/data_manager/scheduler.py`

- Обновить функции уведомлений для использования номера ключа из БД
- Если номера нет, вычислять на основе существующих ключей

4. `src/shop_bot/config.py`

- Обновить функцию `get_key_info_text` для использования номера ключа из БД

## Порядок выполнения

1. Добавить миграцию для поля `keys_count` в таблицу `users`
2. Добавить функцию инициализации счетчика для существующих пользователей
3. Изменить функцию `get_next_key_number` для использования счетчика и атомарного инкремента
4. Добавить логирование в `add_new_key` при IntegrityError для диагностики
5. Добавить логирование номера ключа и email в `process_successful_payment`
6. Обновить функции отображения ключей для использования номера из БД
7. Обновить функции уведомлений для использования номера из БД
8. Протестировать создание и отображение ключей

### To-dos

- [ ] Добавить миграцию для поля keys_count в таблицу users
- [ ] Добавить функцию инициализации счетчика для существующих пользователей
- [ ] Изменить функцию get_next_key_number для использования счетчика keys_count с атомарным инкрементом
- [ ] Добавить функцию increment_user_keys_count для атомарного инкремента счетчика
- [ ] Обновить функцию add_new_key для логирования при IntegrityError
- [ ] Добавить логирование номера ключа и email в process_successful_payment
- [ ] Обновить функции отображения ключей для использования номера из БД
- [ ] Обновить функции уведомлений в scheduler.py для использования номера из БД
- [ ] Протестировать создание и отображение ключей