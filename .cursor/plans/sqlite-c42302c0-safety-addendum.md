# Дополнение к плану: Критические меры безопасности

## ⚠️ КРИТИЧЕСКОЕ ПРЕДУПРЕЖДЕНИЕ ⚠️

**Текущая ситуация**: База данных заблокирована на сервере root@31.56.27.129 после неудачной реализации предыдущего плана (-47ceafa9.plan.md).

**Причина проблемы**: Предыдущая попытка добавить блокировку (_init_lock, _db_initialized) привела к блокировке БД.

**Подход**: Минимальные, безопасные изменения с проверками на каждом шаге. НЕ используем threading.Lock или сложные блокировки.

---

## ЭТАП 0: РАЗБЛОКИРОВКА БД (КРИТИЧНО - ВЫПОЛНИТЬ ПЕРВЫМ!)

**Цель**: Разблокировать базу данных на сервере перед любыми изменениями

**Задачи**:

1. **Проверка текущего состояния на сервере**:
   ```bash
   ssh root@31.56.27.129
   cd /opt/dark-maximus  # или где находится проект
   docker compose ps
   docker compose logs bot --tail=100 | grep -i "locked\|error\|database"
   ls -la /app/project/.db_init.lock 2>/dev/null || echo "Lock file not found"
   lsof /app/project/users.db 2>/dev/null || echo "No processes using DB"
   ```

2. **Разблокировка БД**:
   ```bash
   # Остановить контейнер
   docker compose stop bot
   
   # Подождать 10 секунд для завершения всех операций
   sleep 10
   
   # Проверить процессы с БД (должно быть пусто)
   lsof /app/project/users.db || echo "OK: No processes"
   fuser /app/project/users.db 2>/dev/null || echo "OK: No file handles"
   
   # Удалить файл блокировки, если существует
   rm -f /app/project/.db_init.lock
   
   # Проверить WAL файлы (это нормально, если есть)
   ls -la /app/project/users.db*
   ```

3. **Проверка целостности БД**:
   ```bash
   # Войти в контейнер
   docker compose exec bot python3 -c "
   import sqlite3
   conn = sqlite3.connect('/app/project/users.db')
   cursor = conn.cursor()
   cursor.execute('PRAGMA integrity_check')
   result = cursor.fetchone()
   print('Integrity check:', result[0] if result else 'ERROR')
   conn.close()
   "
   ```
   - Если результат 'ok' - БД в порядке
   - Если есть ошибки - сделать бэкап перед продолжением

4. **Восстановление работоспособности**:
   ```bash
   # Создать бэкап БД
   cp /app/project/users.db /app/project/users.db.backup.$(date +%Y%m%d_%H%M%S)
   
   # Запустить контейнер
   docker compose start bot
   
   # Проверить логи (должно быть без "database is locked")
   docker compose logs bot --tail=50 --follow
   ```

**Критерии успеха**:
- ✅ Контейнер запускается без ошибок "database is locked"
- ✅ БД доступна для чтения и записи
- ✅ Нет зависших процессов с БД
- ✅ Integrity check возвращает 'ok'

**ВАЖНО**: НЕ переходить к следующему этапу, пока ЭТАП 0 не выполнен успешно!

**План отката для ЭТАП 0**:
- Если БД повреждена - восстановить из бэкапа
- Если контейнер не запускается - проверить логи и откатить изменения в коде

---

## Усиленные меры безопасности для ЭТАП 1

### Изменения в задаче 4 (файловая блокировка):

**ВАЖНО**: Использовать ТОЛЬКО `fcntl.flock()` с автоматическим освобождением при завершении процесса

**ЗАПРЕЩЕНО**: 
- threading.Lock
- multiprocessing.Lock
- threading.RLock
- Глобальные переменные для блокировок (_init_lock, _db_initialized)

**Реализация**:
- Создавать файл `.db_init.lock` в директории БД (`/app/project/.db_init.lock`)
- Блокировать файл на время инициализации (exclusive lock, LOCK_EX | LOCK_NB для неблокирующей попытки)
- При блокировке другим процессом - ждать освобождения с таймаутом (30 секунд, НЕ 60!)
- Использовать `try/finally` для гарантированного освобождения блокировки
- **Fallback**: Если блокировка не удалась - использовать ТОЛЬКО retry логику без блокировки

### Проверки после каждого шага ЭТАП 1:

1. После изменения `__main__.py`: проверить локально, что код компилируется (`python -m py_compile src/shop_bot/__main__.py`)
2. После добавления WAL режима: проверить локально запуск приложения
3. После добавления retry логики: проверить локально с симуляцией блокировки
4. После добавления файловой блокировки: проверить локально параллельный запуск
5. **Перед деплоем на сервер**: убедиться, что все работает локально

### План отката для каждого шага ЭТАП 1:

- Если что-то пошло не так - немедленно откатить изменения через `git checkout HEAD -- <file>`
- Не продолжать, если предыдущий шаг не работает
- Иметь готовую команду отката: `git checkout HEAD -- src/shop_bot/__main__.py src/shop_bot/data_manager/database.py && docker compose restart bot`

---

## Дополнительные меры безопасности

1. **Минимальные изменения**: Меняем только то, что необходимо для решения проблемы
2. **Пошаговая проверка**: После каждого изменения проверяем работоспособность локально
3. **Бэкап перед изменениями**: Создать бэкап БД перед деплоем: `cp /app/project/users.db /app/project/users.db.backup.$(date +%Y%m%d_%H%M%S)`
4. **Тестирование на локальной копии**: Сначала протестировать все изменения локально
5. **Мониторинг после деплоя**: Следить за логами первые 30 минут после деплоя: `docker compose logs bot --follow`
6. **Быстрый откат**: Иметь готовую команду для отката: `git checkout HEAD -- src/shop_bot/__main__.py src/shop_bot/data_manager/database.py && docker compose restart bot`
7. **Избегание сложных блокировок**: Использовать простую файловую блокировку через fcntl.flock(), НЕ threading.Lock
8. **Проверка перед коммитом**: Убедиться, что код работает локально перед отправкой на сервер
9. **Не использовать глобальные переменные для блокировок**: Избегать `_init_lock`, `_db_initialized` как глобальных переменных
10. **Простая реализация**: Использовать только стандартные библиотеки Python (fcntl, sqlite3), без дополнительных зависимостей

---

## Обновленный порядок выполнения

1. **ОБЯЗАТЕЛЬНО ПЕРВЫМ**: ЭТАП 0 (разблокировка БД) - восстановление работоспособности
2. **Только после ЭТАП 0**: ЭТАП 1 (критические исправления) - решает текущую проблему
3. **Затем**: ЭТАП 2 (единая обертка) - предотвращает будущие проблемы
4. **После**: ЭТАП 3 (тестирование) - проверка работоспособности
5. **Опционально**: ЭТАП 4 (дополнительные улучшения) - долгосрочные улучшения

**ВАЖНО**: Каждый этап выполняется только после успешного завершения предыдущего!

