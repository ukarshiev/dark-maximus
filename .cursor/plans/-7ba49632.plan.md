<!-- 7ba49632-c877-4eb1-b475-1de4f92827df b0c77ff5-5b37-49b9-a0a2-af9c09d7bf02 -->
# Комплексное исправление блокировки базы данных при инициализации

## Полный анализ проблемы

После ребилда бот не работает из-за ошибки "database is locked". Проблема возникает в **нескольких местах одновременно**:

### Место 1: Конфликт соединений в `initialize_db()` и `run_migration()`

1. В `initialize_db()` создается соединение `conn` с БД (строка 298)
2. Устанавливается WAL режим и PRAGMA настройки
3. Вызывается `run_migration()` (строка 820), которая создает **НОВОЕ** соединение через `with sqlite3.connect(DB_FILE) as conn:` (строка 1133)
4. Это приводит к блокировке БД, потому что первое соединение еще открыто и держит блокировку
5. Миграция падает с ошибкой "database is locked" (строка 2225)

### Место 2: Параллельная инициализация async_db

1. В `__main__.py` (строка 41) сразу после `initialize_db()` вызывается `initialize_async_db()`
2. `initialize_async_db()` создает **10 соединений** через `aiosqlite.connect()` (строка 51 в async_database.py)
3. Если миграция еще не завершилась, это вызывает дополнительные блокировки

### Место 3: Создание бэкапа при инициализации

1. В `__main__.py` (строка 78) вызывается `initialize_backup_system()`
2. `initialize_backup_system()` вызывает `backup_manager.create_backup()` (строка 483)
3. `create_backup()` создает соединение с БД для создания бэкапа (строка 90 в backup.py)
4. Это происходит **одновременно** с миграцией, что может вызвать блокировку

## Комплексное решение

### Этап 1: Исправить конфликт соединений в `run_migration()`

**Файл**: `src/shop_bot/data_manager/database.py`

**Действие 1.1**: Изменить сигнатуру `run_migration()` (строка 1117)

- Добавить опциональный параметр `conn: Optional[sqlite3.Connection] = None`
- Добавить импорт `from typing import Optional` если его нет

**Действие 1.2**: Изменить логику `run_migration()` (строка 1131-1133)

- Если `conn` передан - использовать его и НЕ закрывать в конце
- Если `conn` не передан - создать новое соединение через `with sqlite3.connect(DB_FILE) as conn:` (как сейчас)
- Убедиться, что PRAGMA настройки устанавливаются только если создается новое соединение
- Если соединение передано, проверить что PRAGMA уже установлены (или установить их)

**Действие 1.3**: Передать соединение из `initialize_db()` в `run_migration()` (строка 820)

- Изменить вызов с `run_migration()` на `run_migration(conn)`

**Действие 1.4**: Убедиться, что соединение не закрывается до завершения миграции (строка 846-849)

- `conn.commit()` и `conn.close()` должны выполняться ПОСЛЕ завершения миграции

### Этап 2: Добавить задержку между инициализациями

**Файл**: `src/shop_bot/__main__.py`

**Действие 2.1**: Добавить импорт `time` (если его нет)

- Добавить `import time` в начало файла

**Действие 2.2**: Добавить небольшую задержку после `initialize_db()` (после строки 36)

- Добавить `time.sleep(1)` для гарантии завершения миграции перед созданием async соединений

**Действие 2.3**: Добавить задержку перед `initialize_backup_system()` (после строки 42)

- Добавить `time.sleep(0.5)` для гарантии завершения async инициализации перед созданием бэкапа

### Этап 3: Улучшить обработку ошибок в `initialize_backup_system()`

**Файл**: `src/shop_bot/data_manager/backup.py`

**Действие 3.1**: Добавить retry логику в `create_backup()` при блокировке БД (строка 90)

- Если возникает "database is locked", повторить попытку через 1-2 секунды (до 3 попыток)
- Логировать предупреждение при каждой попытке

**Действие 3.2**: Сделать создание initial_backup опциональным (строка 483)

- Если бэкап не удалось создать из-за блокировки, логировать предупреждение, но не прерывать инициализацию
- Обернуть вызов `create_backup()` в try-except с обработкой блокировки

## Ожидаемый результат

- ✅ Миграция выполняется без ошибки "database is locked"
- ✅ Async соединения создаются после завершения миграции
- ✅ Бэкап создается без конфликтов с миграцией
- ✅ Бот запускается корректно после ребилда
- ✅ Scheduler работает нормально и не показывает "Bot is stopped"
- ✅ Обратная совместимость сохранена для других мест, где вызывается `run_migration()`

## Проверка

После изменений проверить:

1. Логи бота не содержат ошибку "database is locked"
2. Миграция завершается успешно
3. Async соединения создаются без ошибок
4. Бэкап создается успешно (или логируется предупреждение, но инициализация продолжается)
5. Бот запускается и работает нормально
6. Scheduler не показывает "Bot is stopped"

### To-dos

- [ ] Изменить сигнатуру run_migration() - добавить опциональный параметр conn: Optional[sqlite3.Connection] = None
- [ ] Изменить логику run_migration() для использования переданного соединения (если передан - использовать, если нет - создавать новое)
- [ ] Передать соединение из initialize_db() в run_migration() - изменить вызов на run_migration(conn)
- [ ] Проверить, что соединение не закрывается до завершения миграции (conn.commit() и conn.close() после run_migration())