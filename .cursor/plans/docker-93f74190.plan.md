<!-- 93f74190-38c1-48ed-9ff9-833e77d043d3 77e04cd2-19ef-4df8-a8e7-15bf42b6ba7b -->
# Оптимизация времени сборки Docker контейнеров

## Проблема

Сборка контейнеров через `install.sh` занимает более 5 минут (365 секунд). Основные узкие места:

1. **КРИТИЧНО**: В `install.sh` строка 1444 используется `--no-cache`, что заставляет Docker пересобирать ВСЕ слои с нуля
2. **Отсутствие BuildKit**: Нет `DOCKER_BUILDKIT=1`, что не позволяет использовать параллельную сборку и улучшенное кэширование
3. **Большой объем зависимостей**:

   - `yarn install` в codex-docs: 239.2s (почти 4 минуты)
   - `npm install` в bot: 101.4s
   - Python зависимости: 96.1s + 180.1s (в docs)

4. **Нет кэширования слоев**: Из-за `--no-cache` все зависимости устанавливаются заново каждый раз

## Решение

### 1. Сделать `--no-cache` опциональным параметром

**Файл**: `install.sh` (строка 1444)

**Текущий код**:

```bash
${DC[@]} build --no-cache
```

**Изменение**:

- Убрать `--no-cache` по умолчанию (для быстрой сборки с кэшем)
- Добавить обработку параметра `--no-cache` или `--rebuild` через аргументы командной строки
- Поддержать передачу параметра через URL: `curl ... | bash -s -- domain.com --no-cache`

**Новый код**:

```bash
# Определяем, нужно ли использовать --no-cache
BUILD_NO_CACHE=""
if [[ "$*" =~ --no-cache ]] || [[ "$*" =~ --rebuild ]]; then
    BUILD_NO_CACHE="--no-cache"
    echo -e "${YELLOW}⚠️  Режим пересборки: кэш Docker отключен${NC}"
fi

# Собираем и запускаем контейнеры
${DC[@]} build ${BUILD_NO_CACHE}
```

**Эффект**:

- По умолчанию: Docker использует кэш слоев, время сборки ~30-60s при повторных сборках
- С `--no-cache`: Полная пересборка с нуля, время сборки ~365s (как сейчас)

### 2. Включить BuildKit для параллельной сборки

**Файл**: `install.sh` (перед строкой 1444)

**Добавить**:

```bash
export DOCKER_BUILDKIT=1
export COMPOSE_DOCKER_CLI_BUILD=1
```

**Эффект**: Параллельная сборка контейнеров и улучшенное кэширование

### 3. Оптимизировать порядок копирования в Dockerfile.codex-docs

**Файл**: `Dockerfile.codex-docs` (строки 14-21)

**Текущий порядок**: Правильный (сначала зависимости, потом код), но можно улучшить кэширование

**Рекомендация**: Текущий порядок оптимален, но можно добавить `--mount=type=cache` для yarn

### 4. Оптимизировать Dockerfile для bot

**Файл**: `Dockerfile` (строки 1-8)

**Текущий код**:

```dockerfile
FROM node:20-alpine AS assets-builder
WORKDIR /build
COPY package*.json ./
RUN npm install --no-audit --no-fund
```

**Рекомендация**: Добавить `--mount=type=cache` для npm (опционально, требует BuildKit)

### 5. Оптимизировать Dockerfile.docs

**Файл**: `Dockerfile.docs` (строки 15-21)

**Текущий код**: Устанавливает зависимости каждый раз

**Рекомендация**: Порядок правильный, но можно добавить кэширование pip

## Методология работы

**КРИТИЧЕСКИ ВАЖНО:**

1. **Изменять код аккуратно**: 

   - Делать минимальные изменения, только необходимые для решения проблемы
   - Сохранять существующую логику и структуру кода
   - Не ломать существующий функционал

2. **Использовать Context7 MCP**:

   - Перед изменением кода изучить документацию Docker BuildKit через Context7
   - Проверить best practices для Docker multi-stage builds
   - Изучить документацию по docker-compose build опциям

3. **Использовать только факты, не предполагать**:

   - Не выдумывать синтаксис или опции команд
   - Проверять все команды и опции в официальной документации
   - Использовать только проверенные решения

4. **Исследовать и тестировать**:

   - Перед изменением изучить текущую логику обработки аргументов в `install.sh`
   - Проверить, как передаются аргументы через `curl | bash -s --`
   - Протестировать изменения на тестовом окружении
   - Измерить время сборки до и после изменений

## План реализации

### Этап 1: Исследование (ПЕРЕД изменением кода)

1. **Изучить документацию через Context7 MCP**:

   - Docker BuildKit документация
   - docker-compose build опции
   - Best practices для кэширования Docker слоев

2. **Исследовать текущий код**:

   - Изучить логику обработки аргументов в `install.sh` (строки 314-352)
   - Проверить, как передаются аргументы через `curl | bash -s --`
   - Изучить структуру переменной `DC` и команды `docker compose build`

3. **Проанализировать факты из логов**:

   - Время сборки каждого этапа (из предоставленных логов)
   - Какие слои пересобираются при `--no-cache`
   - Какие зависимости занимают больше всего времени

### Этап 2: Реализация (аккуратные изменения)

1. **Добавить BuildKit** в `install.sh` перед сборкой (минимальное изменение)
2. **Сделать `--no-cache` опциональным**:

   - Изучить текущую логику обработки аргументов
   - Добавить проверку аргументов `--no-cache` или `--rebuild`
   - Убрать `--no-cache` по умолчанию

3. **Протестировать изменения**:

   - Запустить сборку без `--no-cache` и измерить время
   - Запустить сборку с `--no-cache` и убедиться, что работает
   - Проверить, что передача через URL работает корректно

## Ожидаемый результат

- **Первая сборка**: ~365s (без изменений, так как зависимости нужно установить)
- **Повторная сборка без изменений**: ~30-60s (использование кэша)
- **Повторная сборка с изменениями в коде**: ~60-120s (кэш зависимостей, пересборка только измененных слоев)

## Файлы для изменения

- `install.sh` - убрать `--no-cache`, добавить BuildKit
- Опционально: `Dockerfile`, `Dockerfile.codex-docs`, `Dockerfile.docs` - добавить кэширование через `--mount=type=cache` (требует BuildKit)

### To-dos

- [ ] Убрать --no-cache из install.sh (строка 1444) или сделать опциональным через переменную окружения DOCKER_BUILD_NO_CACHE
- [ ] Добавить DOCKER_BUILDKIT=1 и COMPOSE_DOCKER_CLI_BUILD=1 в install.sh перед сборкой контейнеров
- [ ] Протестировать время сборки после изменений (первая сборка и повторная сборка)