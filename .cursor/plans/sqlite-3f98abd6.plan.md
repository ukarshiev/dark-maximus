<!-- 3f98abd6-3270-4c3b-93a6-db621a9f2aa8 102f2be5-5ef5-48a2-930b-27c4e1022659 -->
# План тестирования исправлений блокировок базы данных SQLite

## Цель тестирования

Проверить, что все исправления работают корректно и предотвращают ошибки "database is locked" при миграциях.

## Структура тестов

### Файл: `tests/test_database_locks_fix.py`

Используется pytest с fixtures для изолированного тестирования.

## Тест-кейсы

### 1. Тест context manager в run_migration()

**Цель:** Проверить, что соединение правильно закрывается через context manager

**Тест-кейс 1.1:** Проверка автоматического закрытия соединения

- Создать временную БД через fixture
- Вызвать `run_migration()` 
- Проверить, что соединение закрыто автоматически (нет ручных `conn.close()`)
- Проверить, что все миграции выполнены успешно

**Тест-кейс 1.2:** Проверка отсутствия утечек соединений

- Запустить `run_migration()` несколько раз подряд
- Проверить, что нет накопления открытых соединений
- Убедиться, что каждое соединение закрывается после завершения

### 2. Тест PRAGMA busy_timeout и journal_mode=WAL

**Цель:** Проверить, что PRAGMA настройки установлены правильно

**Тест-кейс 2.1:** Проверка PRAGMA busy_timeout=30000

- Создать временную БД
- Вызвать `run_migration()`
- Проверить, что PRAGMA busy_timeout установлен на 30000 мс
- Проверить через `PRAGMA busy_timeout` после выполнения миграции

**Тест-кейс 2.2:** Проверка PRAGMA journal_mode=WAL

- Создать временную БД
- Вызвать `run_migration()`
- Проверить, что journal_mode установлен в WAL
- Проверить через `PRAGMA journal_mode` после выполнения миграции

**Тест-кейс 2.3:** Проверка PRAGMA в migrate_backup_settings()

- Создать временную БД с bot_settings
- Вызвать `migrate_backup_settings()`
- Проверить, что PRAGMA busy_timeout установлен на 30000 мс внутри функции

### 3. Тест retry логики для promo_code_usage

**Цель:** Проверить, что retry логика работает при блокировках

**Тест-кейс 3.1:** Симуляция блокировки и проверка retry

- Создать временную БД
- Заблокировать БД другим соединением (BEGIN EXCLUSIVE TRANSACTION)
- Вызвать миграцию promo_code_usage
- Проверить, что выполняется retry (5 попыток)
- Проверить экспоненциальную задержку (0.5s → 1s → 2s → 4s → 8s)
- Разблокировать БД и проверить успешное завершение

**Тест-кейс 3.2:** Проверка успешного завершения без блокировок

- Создать временную БД
- Вызвать миграцию promo_code_usage без блокировок
- Проверить, что миграция завершается с первой попытки
- Проверить, что retry цикл не выполняется лишний раз

**Тест-кейс 3.3:** Проверка обработки ошибок после всех retry

- Создать временную БД
- Заблокировать БД на время, превышающее все retry попытки
- Вызвать миграцию promo_code_usage
- Проверить, что после 5 неудачных попыток выбрасывается исключение
- Проверить логирование ошибок

### 4. Тест отсутствия блокировок при параллельных операциях

**Цель:** Проверить, что исправления предотвращают блокировки

**Тест-кейс 4.1:** Параллельные миграции

- Создать временную БД
- Запустить `run_migration()` и `migrate_backup_settings()` параллельно (через threading)
- Проверить, что нет ошибок "database is locked"
- Проверить, что обе миграции завершились успешно

**Тест-кейс 4.2:** Миграция + чтение данных

- Создать временную БД с тестовыми данными
- Запустить `run_migration()` в одном потоке
- Одновременно читать данные из БД в другом потоке
- Проверить, что чтение не блокируется
- Проверить, что миграция завершается успешно

**Тест-кейс 4.3:** Множественные соединения с WAL режимом

- Создать временную БД с WAL режимом
- Открыть 5 соединений одновременно
- Выполнить операции записи из разных соединений
- Проверить, что нет ошибок "database is locked"
- Проверить целостность данных

### 5. Интеграционный тест полного сценария миграции

**Цель:** Проверить полный цикл миграции с реальными данными

**Тест-кейс 5.1:** Полная миграция с тестовыми данными

- Создать временную БД с полной структурой (users, vpn_keys, promo_codes, etc.)
- Добавить тестовые данные (100 пользователей, 50 ключей, 10 промокодов)
- Вызвать `initialize_db()` (которая вызывает `run_migration()`)
- Проверить, что все миграции выполнены успешно
- Проверить целостность данных после миграции
- Проверить, что нет ошибок в логах

**Тест-кейс 5.2:** Миграция promo_code_usage с реальными данными

- Создать временную БД с таблицей promo_code_usage (старая структура)
- Добавить тестовые записи (10 записей)
- Вызвать `run_migration()`
- Проверить, что миграция promo_code_usage выполнена успешно
- Проверить, что данные перенесены корректно
- Проверить, что UNIQUE constraint работает правильно

### 6. Тест производительности и стабильности

**Цель:** Проверить, что исправления не ухудшили производительность

**Тест-кейс 6.1:** Время выполнения миграции

- Создать временную БД с тестовыми данными
- Измерить время выполнения `run_migration()`
- Проверить, что время выполнения в пределах разумного (< 5 секунд для тестовой БД)
- Сравнить с базовым временем (если есть)

**Тест-кейс 6.2:** Множественные запуски миграции

- Создать временную БД
- Запустить `run_migration()` 10 раз подряд
- Проверить, что каждый запуск завершается успешно
- Проверить, что нет накопления ошибок или утечек ресурсов

## Технические детали реализации

### Fixtures (pytest)

```python
@pytest.fixture
def temp_db(tmp_path):
    """Создает временную БД для тестов"""
    db_path = tmp_path / "test_users.db"
    # Создать базовую структуру БД
    return db_path

@pytest.fixture
def locked_db(temp_db):
    """Создает БД с активной блокировкой"""
    # Открыть соединение с BEGIN EXCLUSIVE
    # Вернуть объект для управления блокировкой
    pass
```

### Моки и патчи

- Использовать `unittest.mock` для симуляции блокировок
- Использовать `threading` для параллельных операций
- Использовать `time.sleep` для контроля времени в retry логике

### Проверки

- Проверять логи через `caplog` fixture pytest
- Проверять PRAGMA настройки через прямое выполнение SQL
- Проверять состояние БД после миграций

## Ожидаемые результаты

1. Все тесты проходят успешно
2. Нет ошибок "database is locked" в логах
3. PRAGMA настройки установлены корректно
4. Retry логика работает при блокировках
5. Context manager правильно управляет соединениями
6. Производительность не ухудшилась

## Критерии успеха

- ✅ Все тесты проходят (100% success rate)
- ✅ Нет ошибок "database is locked" в тестах
- ✅ Retry логика срабатывает при блокировках
- ✅ PRAGMA настройки установлены во всех нужных местах
- ✅ Context manager работает правильно
- ✅ Интеграционные тесты подтверждают работоспособность

### To-dos

- [ ] Переделать run_migration() для использования context manager вместо ручного создания соединения - устранить двойное соединение
- [ ] Добавить PRAGMA busy_timeout=30000 и PRAGMA journal_mode=WAL в run_migration() после создания соединения
- [ ] Добавить retry логику для миграции promo_code_usage unique constraint (5 попыток, экспоненциальная задержка)
- [ ] Добавить PRAGMA busy_timeout, PRAGMA journal_mode=WAL и retry логику в функцию migrate_backup_settings()
- [ ] Добавить PRAGMA busy_timeout=30000 и PRAGMA journal_mode=WAL в initialize_db() для единообразных настроек